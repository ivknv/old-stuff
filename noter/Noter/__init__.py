#!/usr/bin/env python
# -*- coding: utf-8 -*-

# all the comments except this are autogenerated with CodeCommenter
# see https://github.com/SPython/code-commenter

import sqlite3, os

ID=0
TITLE=1
TEXT=2
TAGS=4
DATE=3

class Note(object):
	def __init__(self, note):
		self.id = note[ID]
		self.title = note[TITLE]
		self.date = note[DATE]
		self.text = note[TEXT]
		try:
			self.tags = note[TAGS].split(",")
			self.tags=[tag[1:] if tag[0] == " " else tag for tag in self.tags]
		except TypeError:
			self.tags = ""
	
	def __call__(self):
		return [self.id, self.title, self.text, self.tags, self.date]
	
	def __repr__(self):
		return "<Note: {}>".format(self.title)
	
	def __getitem__(self, i):
		return self()[i]

def init(db=os.path.expanduser("~/notes.db")): # Initialize database for keeping notes
	con = sqlite3.connect(db) # Connect SQLite database
	try:
		cur = con.cursor() # Get cursor
		cur.execute("CREATE TABLE notes(id INTEGER PRIMARY KEY AUTOINCREMENT, title VARCHAR(100), text TEXT, tags VARCHAR, date TIMESTAMP DEFAULT CURRENT_TIMESTAMP)") # Execute SQLite command
		con.commit()
	finally:
		con.close()

def add_note(title, text, tags="", db=os.path.expanduser("~/notes.db")): # Add a new note
	con = sqlite3.connect(db) # Connect SQLite database
	try:
		cur = con.cursor() # Get cursor
		cur.execute("INSERT INTO notes(title, text, tags) VALUES(\"{title}\", \"{text}\", \"{tags}\");".format(title=title, text=text, tags=tags)) # Execute SQLite command
		con.commit()
	finally:
		con.close()

def rm_note(id=None, title=None, db=os.path.expanduser("~/notes.db")): # Remove note
	if id or title:
		con = sqlite3.connect(db) # Connect SQLite database
		try:
			cur = con.cursor() # Get cursor
			if id and not title:
				cur.execute("DELETE FROM notes WHERE id={};".format(id)) # Execute SQLite command
			elif title and not id:
				cur.execute("DELETE FROM notes WHERE title=\"{}\";".format(title)) # Execute SQLite command
			elif id and title:
				cur.execute("DELETE FROM notes WHERE id={} AND title=\"{}\"".format(id, title)) # Execute SQLite command
			con.commit()
		finally:
			con.close()

def read(db=os.path.expanduser("~/notes.db"), slice_string="0:", return_objects=False):
	slice_string=[int(s) for s in slice_string.split(":") if s]
	con = sqlite3.connect(db) # Connect SQLite database
	try:
		cur = con.cursor() # Get cursor
		cur.execute("SELECT * FROM notes;") # Execute SQLite command
		if len(slice_string) == 2:
			notes = cur.fetchall()[slice_string[0]:slice_string[1]] # Get result of executing SQLite command
		else:
			notes = cur.fetchall()[slice_string[0]:] # Get result of executing SQLite command
	finally:
		con.close()
	return [Note(note) for note in notes] if return_objects else [list(note) for note in notes]

def get(id, db=os.path.expanduser("~/notes.db"), return_object=False): # Get note by id
	if id:
		con = sqlite3.connect(db) # Connect SQLite database
		try:
			cur = con.cursor() # Get cursor
			cur.execute("SELECT * FROM notes WHERE id={};".format(id)) # Execute SQLite command
			found=cur.fetchall() # Get result of executing SQLite command
		finally:
			con.close()
		return Note(found[0]) if return_object else found[0]

def edit_note(id, title=None, text=None, tags=None, db=os.path.expanduser("~/notes.db")): # Edit note
	if id and (title or text):
		con = sqlite3.connect(db) # Connect SQLite database
		try:
			cur = con.cursor() # Get cursor
			if text:
				cur.execute("UPDATE notes SET text=\"{}\" WHERE id={};".format(text, id)) # Execute SQLite command
			if title:
				cur.execute("UPDATE notes SET title=\"{}\" WHERE id={};".format(title, id)) # Execute SQLite command
			if tags:
				cur.execute("UPDATE notes SET tags=\"{tags}\" WHERE id={id};".format(tags=tags, id=id)) # Execute SQLite command
			con.commit()
		finally:
			con.close()
		return True
	return False

def PlaceByRelevance(qs, notes, splitted=False, lower=False):
	found = []
	if not lower:
		qs = qs.lower()
	if not splitted:
		qs = qs.split()
	for note in notes:
		for q in qs:
			title = note[TITLE].lower()
			text = note[TEXT].lower()
			tags = note[TAGS].lower()
			if q in title or q in text or q in tags:
				found.append([
					-title.count(q)*1.5-text.count(q)-tags.count(q)*2,
					note
				])
	found.sort()
	return found

def fix_tags(notes):
	for i in range(len(notes)):
		if notes[i][TAGS] is None:
			notes[i][TAGS] = ""
	return notes

def search(q, db=os.path.expanduser("~/notes.db"), return_objects=False):
	q = q.lower()
	found = []
	notes = fix_tags(read(db=db))
	found = PlaceByRelevance(q, notes, lower=True)
	return [Note(note[1]) for note in found] if return_objects else found

def transform_tags(tags, lower=False):
	if not lower:
		tags = tags.lower()
	tags = tags.split(",")
	
	for i in range(len(tags)):
		if tags[i][0] == " ":
			tags[i] = tags[i][1:]
	return tags

def filter_notes(tags, db=os.path.expanduser("~/noter.db"), return_objects=False):
	
	notes = fix_tags(read(db=db))
	filtered = []
	tags = transform_tags(tags)
	for note in notes:
		has_tag = True
		for tag in tags:
			if tag not in note[TAGS]:
				has_tag = False
				break
		if has_tag:
			filtered.append(note)
	
	return [Note(note) for note in filtered] if return_objects else filtered
